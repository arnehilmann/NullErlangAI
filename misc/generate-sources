#!/usr/bin/env python
from __future__ import print_function

import os
import re
import sys
from textwrap import dedent

misc_dirname = os.path.dirname(os.path.abspath(__file__))
eventdef_filename = os.path.join(misc_dirname,
                                 "../../../../rts/ExternalAI/Interface/AISEvents.h")
eventdef_filename = os.path.abspath(eventdef_filename)

eventgen_filename = os.path.join(misc_dirname, "../src/events.c")
eventgen_filename = os.path.abspath(eventgen_filename)

events = {}
with open(eventdef_filename) as eventdef_file:
    parsing = False
    for line in eventdef_file:
        if parsing and line.startswith("};"):
            break
        if line.startswith("enum EventTopic"):
            parsing = True
        if not parsing:
            continue
        if "=" not in line:
            continue
        name, _ = line.split("=")
        name = name.strip()
        # print(name)
        events[name] = {}

with open(eventdef_filename) as eventdef_file:
    parsing = False
    args = []
    struct_name = None
    for line in eventdef_file:
        if line.startswith("struct "):
            parsing = True
            args = []
            struct_name = line.strip().replace(" {", "")
            continue
        if line.startswith("}; //$ "):
            parsing = False
            name = line.strip().split(" ")[2]
            # print("%s found" % name)
            events[name] = (struct_name, args)
        if not parsing:
            continue
        line = line.strip()
        if line.startswith("/") or line.startswith("*"):
            continue
        m = re.match("^\s*(.*)\s(\S+);$", line)
        if m:
            args.append((m.group(2), m.group(1)))

def indent(indent, s):
    return "    " * indent + s

def wrap_encode(i, value, c_type, encode_type):
    lines = []
    lines.append(indent(i, 'fprintf(stderr, "    encoding %s\\n", %s);' % (c_type, value)))
    lines.append(indent(i, "if (ei_x_encode_%s(sendbuf, %s) < 0) {" % (encode_type, value)))
    #lines.append(indent(i + 1, """fprintf(stderr, "cannot encode '%s' as '%s'\\n", %s);""" % (c_type, encode_type, value)))
    lines.append(indent(i + 1, 'return -1;'))
    lines.append(indent(i, "}"))
    return "\n".join(lines)

gen_src = []
for name in sorted(events):
    params = events[name]
    if not params:
        continue
    lines = []
    struct_name, args = params
    lines.append(indent(2, "case %s: {" % name))
    lines.append(indent(3, 'fprintf(stderr, "encoding %s\\n");' % name))
    lines.append(indent(3, "ei_x_encode_atom(sendbuf, \"%s\");" % name.lower()))
    lines.append(indent(3, "%s* event_data = (%s*)data;" % (struct_name, struct_name)))
    lines.append(indent(3, "ei_x_encode_tuple_header(sendbuf, %i);" % (2 * len(args))))
    unknown_types = False
    for arg in args:
        arg_name, arg_type = arg
        lines.append(indent(3, "{"))
        #lines.append(indent(4, 'fprintf(stderr, "    encoding %s\\n");' % arg_name))
        #lines.append(indent(4, 'const char* arg_name = "%s";' % arg_name))
        lines.append(wrap_encode(4, '"%s"' % arg_name.lower(), "%s", "atom"))
#        lines.append(indent(3, "if ("))
#        lines.append(indent(4, "ei_x_encode_atom(sendbuf, \"%s\")" % arg_name))
        if arg_type == "int":
            lines.append(wrap_encode(4, "event_data->%s" % arg_name, "%i", "long"))
#            lines.append(indent(4, "ei_x_encode_long(sendbuf, event_data->%s)" % arg_name))
        elif arg_type == "const char*":
            lines.append(wrap_encode(4, "event_data->%s" % arg_name, "%s", "string"))
#            lines.append(indent(4, "ei_x_encode_string(sendbuf, event_data->%s)" % arg_name))
        elif arg_type == "float":
            lines.append(wrap_encode(4, "event_data->%s" % arg_name, "%f", "double"))
#            lines.append(indent(4, "ei_x_encode_double(sendbuf, event_data->%s)" % arg_name))
        else:
            print("%s: no src generated due to unknown type %s" % (name, arg_type), file=sys.stderr)
            unknown_types = True
        lines.append(indent(3, "}"))
#        lines.append(indent(3, "< 0) {"))
#        lines.append(indent(4, 'fprintf(stderr, "cannot encode arg %s [%s] with value %%s", event_data->arg_name);' % (arg_name, arg_type)))
#        lines.append(indent(3, "}"))
    lines.append(indent(3, "break;"))
    lines.append(indent(2, "}"))
    if not unknown_types:
        gen_src.extend(lines)

with open(eventgen_filename, "w") as eventgen_file:
    eventgen_file.write(dedent("""
        #include "ei.h"
        #include "rts/ExternalAI/Interface/AISEvents.h"

        int add_event_data(ei_x_buff* sendbuf, int topic, const void* data) {
            switch (topic) {
        """))
    eventgen_file.write("\n".join(gen_src))
    eventgen_file.write(dedent("""
                default: {
                    ei_x_encode_long(sendbuf, topic);
                    ei_x_encode_binary(sendbuf, data, sizeof(data));
                }
            }
            return 0;
        }
        """))
