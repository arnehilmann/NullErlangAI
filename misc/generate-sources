#!/usr/bin/env python
from __future__ import print_function

import os
import re
import sys
from textwrap import dedent

def indent(indent, s):
    return "    " * indent + s


def wrap_encode(i, value, c_type, encode_type):
    lines = []
    #lines.append(indent(i, 'fprintf(stderr, "    encoding %s\\n", %s);' % (c_type, value)))
    lines.append(indent(i, "if (ei_x_encode_%s(sendbuf, %s) < 0) {" % (encode_type, value)))
    lines.append(indent(i + 1, """fprintf(stderr, "cannot encode '%s' as '%s'\\n", %s);""" % (c_type, encode_type, value)))
    lines.append(indent(i + 1, 'return -1;'))
    lines.append(indent(i, "}"))
    return "\n".join(lines)


class SourceGeneratorEvents(object):
    def __init__(self, cwd):
        self.eventdef_filename = os.path.join(cwd,
                                        "../../../../rts/ExternalAI/Interface/AISEvents.h")
        self.eventdef_filename = os.path.abspath(self.eventdef_filename)

        self.eventgen_filename = os.path.join(cwd, "../src/events.c")
        self.eventgen_filename = os.path.abspath(self.eventgen_filename)

        self.events = {}

    def _find_all_event_names(self):
        with open(self.eventdef_filename) as eventdef_file:
            parsing = False
            for line in eventdef_file:
                if parsing and line.startswith("};"):
                    break
                if line.startswith("enum EventTopic"):
                    parsing = True
                if not parsing:
                    continue
                if "=" not in line:
                    continue
                name, _ = line.split("=")
                name = name.strip()
                # print(name)
                self.events[name] = {}

    def _find_all_event_definitions(self):
        with open(self.eventdef_filename) as eventdef_file:
            parsing = False
            args = []
            struct_name = None
            for line in eventdef_file:
                if line.startswith("struct "):
                    parsing = True
                    args = []
                    struct_name = line.strip().replace(" {", "")
                    continue
                if line.startswith("}; //$ "):
                    parsing = False
                    name = line.strip().split(" ")[2]
                    # print("%s found" % name)
                    self.events[name] = (struct_name, args)
                if not parsing:
                    continue
                line = line.strip()
                if line.startswith("/") or line.startswith("*"):
                    continue
                m = re.match("^\s*(.*)\s(\S+);$", line)
                if m:
                    args.append((m.group(2), m.group(1)))

    def _render_c_source(self):
        gen_src = []
        for name in sorted(self.events):
            params = self.events[name]
            if not params:
                continue
            lines = []
            struct_name, args = params
            lines.append(indent(2, "case %s: {" % name))
            lines.append(indent(3, "ei_x_encode_atom(sendbuf, \"%s\");" % name.lower()))
            lines.append(indent(3, "%s* event_data = (%s*)data;" % (struct_name, struct_name)))
            lines.append(indent(3, "ei_x_encode_tuple_header(sendbuf, %i);" % (2 * len(args))))
            unknown_types = False
            for arg in args:
                arg_name, arg_type = arg
                lines.append(indent(3, "{"))
                lines.append(wrap_encode(4, '"%s"' % arg_name.lower(), "%s", "atom"))
                if arg_type == "int":
                    lines.append(wrap_encode(4, "event_data->%s" % arg_name, "%i", "long"))
                elif arg_type == "const char*":
                    lines.append(wrap_encode(4, "event_data->%s" % arg_name, "%s", "string"))
                elif arg_type == "float":
                    lines.append(wrap_encode(4, "event_data->%s" % arg_name, "%f", "double"))
                elif arg_type == "float*":
                    lines.append(wrap_encode(4, "3", "%i", "tuple_header"))
                    lines.append(wrap_encode(4, "event_data->%s[0]" % arg_name, "%f", "double"))
                    lines.append(wrap_encode(4, "event_data->%s[1]" % arg_name, "%f", "double"))
                    lines.append(wrap_encode(4, "event_data->%s[2]" % arg_name, "%f", "double"))
                elif arg_type == "bool":
                    lines.append(wrap_encode(4, 'event_data->%s ? "true" : "false"' % arg_name, "%s", "atom"))
                else:
                    print("%s: no src generated due to unknown type %s" % (name, arg_type), file=sys.stderr)
                    unknown_types = True
                lines.append(indent(3, "}"))
            lines.append(indent(3, "break;"))
            lines.append(indent(2, "}"))
            if not unknown_types:
                gen_src.extend(lines)

        with open(self.eventgen_filename, "w") as eventgen_file:
            eventgen_file.write(dedent("""
                /* THIS FILE GETS GENERATED, DO NOT EDIT DIRECTLY! */

                #include "ei.h"
                #include "rts/ExternalAI/Interface/AISEvents.h"

                int add_event_data(ei_x_buff* sendbuf, int topic, const void* data) {
                    switch (topic) {
                """))
            eventgen_file.write("\n".join(gen_src))
            eventgen_file.write(dedent("""
                        default: {
                            ei_x_encode_long(sendbuf, topic);
                            ei_x_encode_binary(sendbuf, data, sizeof(data));
                        }
                    }
                    return 0;
                }
                """))

    def generate(self):
        self._find_all_event_names()
        self._find_all_event_definitions()
        self._render_c_source()


class SourceGeneraterCallbacks(object):
    def __init__(self, cw):
        self.cbdef_filename = os.path.join(cwd,
                                        "../../../../rts/ExternalAI/Interface/SSkirmishAICallback.h")
        self.cbdef_filename = os.path.abspath(self.cbdef_filename)

        self.cbgen_filename = os.path.join(cwd, "../src/callbacks.c")
        self.cbgen_filename = os.path.abspath(self.cbgen_filename)

        self.cbs = {}




if __name__ == "__main__":
    misc_dirname = os.path.dirname(os.path.abspath(__file__))
    SourceGeneratorEvents(misc_dirname).generate()

