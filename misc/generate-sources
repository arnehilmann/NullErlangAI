#!/usr/bin/env python
from __future__ import print_function

import os
import re
import sys
from textwrap import dedent

def indent(indent, s):
    return "    " * indent + s


def wrap_encode(i, value, c_type, encode_type):
    lines = []
    #lines.append(indent(i, 'fprintf(stderr, "    encoding %s\\n", %s);' % (c_type, value)))
    lines.append(indent(i, "if (ei_x_encode_%s(sendbuf, %s) < 0) {" % (encode_type, value)))
    lines.append(indent(i + 1, """fprintf(stderr, "cannot encode '%s' as '%s'\\n", %s);""" % (c_type, encode_type, value)))
    lines.append(indent(i + 1, 'return -1;'))
    lines.append(indent(i, "}"))
    return "\n".join(lines)


def find_all_structs(f, start_token, end_token):
    result = {}
    parsing = False
    args = []
    struct_name = None
    for line in f:
        if line.startswith(start_token):
            parsing = True
            args = []
            struct_name = line.strip().replace(" {", "")
            continue
        if line.startswith(end_token):
            parsing = False
            name = line.strip().split(" ")[2]
            # print("%s found" % name)
            result[name] = (struct_name, args)
        if not parsing:
            continue
        line = line.strip()
        if line.startswith("/") or line.startswith("*"):
            continue
        m = re.match("^\s*(.*)\s(\S+);$", line)
        if m:
            args.append((m.group(2), m.group(1)))
    return result


class SourceGeneratorCommands(object):
    def __init__(self, cwd):
        self.commanddef_filename = os.path.join(cwd,
                                                "../../../../rts/ExternalAI/Interface/AISCommands.h")
        self.commanddef_filename = os.path.abspath(self.commanddef_filename)

        self.commandgen_filename = os.path.join(cwd, "../src/commands.c")
        self.commandgen_filename = os.path.abspath(self.commandgen_filename)

        self.commands = {}

    def generate(self):
        with open(self.commanddef_filename) as commanddef_file:
            self.commands = find_all_structs(commanddef_file, "struct", "}; //$ ")
            #import json
            #print(json.dumps(self.commands, indent=4))

        with open(self.commandgen_filename, "w") as commandgen_file:
            commandgen_file.write(dedent("""
                /* GENERATED FILE, DO NOT EDIT DIRECTLY */

                #include "commands.h"

                #include <string.h>
                #include "ei.h"

                #include "rts/ExternalAI/Interface/AISCommands.h"

                #include "send_to.h"

                int handle_command(int team_id, const struct SSkirmishAICallback* callback, char* recvbuff, int index) {
                    char command[64] = "";
                    ei_decode_atom(recvbuff, &index, command);

                """))
            for name in sorted(self.commands):
                #if "PATH_INIT" not in name:
                #    continue
                lines = []
                lines.append(indent(1, 'if (strcmp(command, "%s") == 0) {' % name))
                struct, args = self.commands[name]
                ok = True
                nr_out_args = 0
                for arg_name, arg_type in args:
                    if "ret_" in arg_name:
                        lines.append(indent(2, '%s %s;' % (arg_type, arg_name)))
                        nr_out_args += 1
                    else:
                        if arg_type in ("int", "short"):
                            lines.append(indent(2, 'long %s_tmp;' % arg_name))
                            lines.append(indent(2, 'ei_decode_long(recvbuff, &index, &%s_tmp);' % arg_name))
                            lines.append(indent(2, '%s %s = (%s)%s_tmp;' % (arg_type, arg_name, arg_type, arg_name)))
                        elif arg_type == "float":
                            lines.append(indent(2, 'double %s_tmp;' % arg_name))
                            lines.append(indent(2, 'ei_decode_double(recvbuff, &index, &%s_tmp);' % arg_name))
                            lines.append(indent(2, '%s %s = (float)%s_tmp;' % (arg_type, arg_name, arg_name)))
                        elif arg_type == "float*":
                            lines.append(indent(2, 'float %s[3];' % arg_name))
                            lines.append(indent(2, 'double %s_tmp;' % arg_name))
                            lines.append(indent(2, 'ei_decode_double(recvbuff, &index, &%s_tmp);' % arg_name))
                            lines.append(indent(2, '%s[0] = (float)%s_tmp;' % (arg_name, arg_name)))
                            lines.append(indent(2, 'ei_decode_double(recvbuff, &index, &%s_tmp);' % arg_name))
                            lines.append(indent(2, '%s[1] = (float)%s_tmp;' % (arg_name, arg_name)))
                            lines.append(indent(2, 'ei_decode_double(recvbuff, &index, &%s_tmp);' % arg_name))
                            lines.append(indent(2, '%s[2] = (float)%s_tmp;' % (arg_name, arg_name)))
                        else:
                            print("%s: unknown arg_type %s" % (name, arg_type))
                            ok = False
                if not ok:
                    continue
                lines.append(indent(2, '%s command = {' % struct))
                for arg_name, arg_type in args:
                    lines.append(indent(3, '%s,' % arg_name))
                lines.append(indent(2, '};'))
                lines.append(indent(2, 'erlang_pid from;'))
                lines.append(indent(2, 'ei_decode_pid(recvbuff, &index, &from);'))
                lines.append(indent(2, 'if (callback->Engine_handleCommand(team_id, team_id, -1, %s, &command) < 0) {;' % name))
                lines.append(indent(3, 'answer_error(team_id, &from);'))
                lines.append(indent(2, '} else {'))
                lines.append(indent(3, 'ei_x_buff sendbuff;'))
                lines.append(indent(3, 'ei_x_new_with_version(&sendbuff);'))
                lines.append(indent(3, 'ei_x_encode_tuple_header(&sendbuff, %i);' % (1 + 2 * nr_out_args)))
                lines.append(indent(3, 'ei_x_encode_atom(&sendbuff, "ok");'))
                for arg_name, arg_type in args:
                    if "ret_" in arg_name:
                        lines.append(indent(3, 'ei_x_encode_atom(&sendbuff, "%s");' % arg_name))
                        if arg_type == "int":
                            lines.append(indent(3, 'ei_x_encode_long(&sendbuff, command.%s);' % arg_name))
                        else:
                            print("%s: unknown ret_ arg_type %s", name, arg_type);
                            ok = False
                if not ok:
                    continue
                lines.append(indent(3, "send_to_pid(team_id, &from, sendbuff);"))
                lines.append(indent(2, "}"))
                lines.append(indent(1, "}"))
                lines.append("")
                commandgen_file.write("\n".join(lines))

            commandgen_file.write("}")


#int move_unit(int team_id, int unit_id, float* pos) {
    #struct SMoveUnitCommand move_command = {
        #unit_id,
        #-1,
        #0,
        #INT_MAX,
        #pos
    #};
    #callbacks[team_id]->Engine_handleCommand(team_id, team_id, -1, COMMAND_UNIT_MOVE, &move_command);
#}


class SourceGeneratorEvents(object):
    def __init__(self, cwd):
        self.eventdef_filename = os.path.join(cwd,
                                        "../../../../rts/ExternalAI/Interface/AISEvents.h")
        self.eventdef_filename = os.path.abspath(self.eventdef_filename)

        self.eventgen_filename = os.path.join(cwd, "../src/events.c")
        self.eventgen_filename = os.path.abspath(self.eventgen_filename)

        self.events = {}

    def _find_all_event_names(self):
        with open(self.eventdef_filename) as eventdef_file:
            parsing = False
            for line in eventdef_file:
                if parsing and line.startswith("};"):
                    break
                if line.startswith("enum EventTopic"):
                    parsing = True
                if not parsing:
                    continue
                if "=" not in line:
                    continue
                name, _ = line.split("=")
                name = name.strip()
                # print(name)
                self.events[name] = {}

    def _find_all_event_definitions(self):
        with open(self.eventdef_filename) as eventdef_file:
            self.events = find_all_structs(eventdef_file, "struct", "}; //$ ")

    def _render_c_source(self):
        gen_src = []
        for name in sorted(self.events):
            params = self.events[name]
            if not params:
                continue
            lines = []
            struct_name, args = params
            lines.append(indent(2, "case %s: {" % name))
            lines.append(indent(3, "ei_x_encode_atom(sendbuf, \"%s\");" % name.lower()))
            lines.append(indent(3, "%s* event_data = (%s*)data;" % (struct_name, struct_name)))
            lines.append(indent(3, "ei_x_encode_tuple_header(sendbuf, %i);" % (2 * len(args))))
            unknown_types = False
            for arg in args:
                arg_name, arg_type = arg
                lines.append(indent(3, "{"))
                lines.append(wrap_encode(4, '"%s"' % arg_name.lower(), "%s", "atom"))
                if arg_type == "int":
                    lines.append(wrap_encode(4, "event_data->%s" % arg_name, "%i", "long"))
                elif arg_type == "const char*":
                    lines.append(wrap_encode(4, "event_data->%s" % arg_name, "%s", "string"))
                elif arg_type == "float":
                    lines.append(wrap_encode(4, "event_data->%s" % arg_name, "%f", "double"))
                elif arg_type == "float*":
                    lines.append(wrap_encode(4, "3", "%i", "tuple_header"))
                    lines.append(wrap_encode(4, "event_data->%s[0]" % arg_name, "%f", "double"))
                    lines.append(wrap_encode(4, "event_data->%s[1]" % arg_name, "%f", "double"))
                    lines.append(wrap_encode(4, "event_data->%s[2]" % arg_name, "%f", "double"))
                elif arg_type == "bool":
                    lines.append(wrap_encode(4, 'event_data->%s ? "true" : "false"' % arg_name, "%s", "atom"))
                else:
                    print("%s: no src generated due to unknown type %s" % (name, arg_type), file=sys.stderr)
                    unknown_types = True
                lines.append(indent(3, "}"))
            lines.append(indent(3, "break;"))
            lines.append(indent(2, "}"))
            if not unknown_types:
                gen_src.extend(lines)

        with open(self.eventgen_filename, "w") as eventgen_file:
            eventgen_file.write(dedent("""
                /* THIS FILE GETS GENERATED, DO NOT EDIT DIRECTLY! */

                #include "ei.h"
                #include "rts/ExternalAI/Interface/AISEvents.h"

                int add_event_data(ei_x_buff* sendbuf, int topic, const void* data) {
                    switch (topic) {
                """))
            eventgen_file.write("\n".join(gen_src))
            eventgen_file.write(dedent("""
                        default: {
                            ei_x_encode_long(sendbuf, topic);
                            ei_x_encode_binary(sendbuf, data, sizeof(data));
                        }
                    }
                    return 0;
                }
                """))

    def generate(self):
        self._find_all_event_names()
        self._find_all_event_definitions()
        self._render_c_source()


class SourceGeneratorCallbacks(object):
    def __init__(self, cw):
        self.cbdef_filename = os.path.join(cw,
                                        "../../../../rts/ExternalAI/Interface/SSkirmishAICallback.h")
        self.cbdef_filename = os.path.abspath(self.cbdef_filename)

        self.cbgen_filename = os.path.join(cw, "../src/callbacks.c")
        self.cbgen_filename = os.path.abspath(self.cbgen_filename)

        self.docs_filename = os.path.join(cw, "../src/callbacks.doc")
        self.docs_filename = os.path.abspath(self.docs_filename)

        self.cbs = {}

    def generate(self):
        self._find_all_callback_definitions()
        self._render_c_source()

    def _find_all_callback_definitions(self):
        with open(self.cbdef_filename) as cbdef_file:
            for line in cbdef_file:
                if "CALLING_CONV" not in line:
                    continue
                if line.startswith("//"):
                    continue
                match = re.match("^\s*(.+)\s+\(CALLING_CONV \*([^\)]+)\)\((.*)\);(.*)$", line)
                if not match:
                    continue
                name = match.group(2)
                cb_returns = match.group(1).strip()
                cb_args = []
                for arg in match.group(3).split(","):
                    arg_type, arg_name = arg.rsplit(None, 1)
                    cb_args.append((arg_type.strip(), arg_name.strip()))
                meta = match.group(4)
                fetched = "____"
                fetched_maxsize = "____"
                if "MULTI" in meta:
                    fetched = meta.split(":")[-1]
                    fetched = fetched.split("->")[0]
                    print(fetched)
                    fetched_maxsize = fetched + "_sizeMax"
                    print(fetched_maxsize)

                ext_args = []
                fetched_arg = None
                fetched_size_arg = None
                for arg in cb_args[1:]:
                    arg_type, arg_name = arg
                    if fetched == arg_name:
                        fetched_arg = arg
                    else:
                        ext_args.append(arg)
                        if arg_name == fetched_maxsize:
                            fetched_size_arg = arg_name


                self.cbs[name] = {"cb_name": name,
                                  "cb_returns": cb_returns,
                                  "cb_args": cb_args,
                                  "ext_args": ext_args,
                                  "fetched_arg": fetched_arg,
                                  "fetched_size_arg": fetched_size_arg
                                  }


    def _render_c_source(self):
        import json
        print(json.dumps(self.cbs, indent=4, sort_keys=True))
        with open(self.cbgen_filename, "w") as cbgen_file:
            with open(self.docs_filename, "w") as doc_file:
                cbgen_file.write(dedent("""
                    /* THIS FILE GETS GENERATED, DO NOT EDIT DIRECTLY! */

                    #include <string.h>

                    #include "ei.h"
                    #include "rts/ExternalAI/Interface/SSkirmishAICallback.h"
                    #include "send_to.h"

                    int handle_callback(int skirmishAIId, const struct SSkirmishAICallback* callback, char* recvbuff, int index){
                        char callback_what[64] = "";
                        ei_decode_atom(recvbuff, &index, callback_what);

                """))
                for name in sorted(self.cbs):
                    cb = self.cbs[name]
                    lines = []
                    docs = [":callback", ":%s" % name]

                    lines.append(indent(1, 'if (strcmp(callback_what, "%s") == 0) {' % cb["cb_name"]))

                    ok = True
                    for arg in cb["ext_args"]:
                        arg_type, arg_name = arg
                        docs.append("%s[%s]" % (arg_name, arg_type))
                        if arg_type == "int":
                            lines.append(indent(2, 'long %s;' % arg_name))
                            lines.append(indent(2, 'ei_decode_long(recvbuff, &index, &%s);' % arg_name))
                        elif arg_type == "float":
                            lines.append(indent(2, 'double %s;' % arg_name))
                            lines.append(indent(2, 'ei_decode_double(recvbuff, &index, &%s);' % arg_name))
                        elif arg_type == "bool":
                            lines.append(indent(2, 'int %s;' % arg_name))
                            lines.append(indent(2, 'ei_decode_boolean(recvbuff, &index, &%s);' % arg_name))
                        elif arg_type in ("char*", "const char*", "const char* const"):
                            lines.append(indent(2, 'char* %s;' % arg_name))
                            lines.append(indent(2, 'ei_decode_string(recvbuff, &index, %s);' % arg_name))
                        elif "posF3" in arg_name and arg_type == "float*":
                            lines.append(indent(2, 'float %s[3];' % arg_name))
                            lines.append(indent(2, 'double tmp;'))
                            lines.append(indent(2, 'ei_decode_double(recvbuff, &index, &tmp);'))
                            lines.append(indent(2, '%s[0] = tmp;' % arg_name))
                            lines.append(indent(2, 'ei_decode_double(recvbuff, &index, &tmp);'))
                            lines.append(indent(2, '%s[1] = tmp;' % arg_name))
                            lines.append(indent(2, 'ei_decode_double(recvbuff, &index, &tmp);'))
                            lines.append(indent(2, '%s[2] = tmp;' % arg_name))
                        else:
                            print("%s:%s: unknown arg type %s" % (name, arg_name, arg_type))
                            ok = False
                    if not ok:
                        continue
                    if cb["fetched_arg"]:
                        fetched_type, fetched_name = cb["fetched_arg"]
                        fetched_type = fetched_type.replace("*", "")
                        lines.append(indent(2, '%s %s[%s];' % (fetched_type, fetched_name, cb["fetched_size_arg"])))
                    lines.append(indent(2, 'erlang_pid from;'))
                    lines.append(indent(2, 'ei_decode_pid(recvbuff, &index, &from);'))
                    docs.append("from[pid]")

                    lines.append(indent(2, '%s result = callback->%s(%s);' % (cb["cb_returns"], cb["cb_name"], ", ".join(name for t, name in cb["cb_args"]))))

                    lines.append(indent(2, 'ei_x_buff sendbuff;'))
                    lines.append(indent(2, 'ei_x_new_with_version(&sendbuff);'))
                    lines.append(indent(2, 'ei_x_encode_tuple_header(&sendbuff, 3);'))
                    lines.append(indent(2, 'ei_x_encode_atom(&sendbuff, "result");'))
                    lines.append(indent(2, 'ei_x_encode_atom(&sendbuff, "%s");' % cb["cb_name"]))
                    docs.append("->")
                    docs.append(":result")
                    docs.append(":%s" % cb["cb_name"])
                    if cb["fetched_arg"]:
                        fetched_type, fetched_name = cb["fetched_arg"]
                        lines.append(indent(2, 'ei_x_encode_list_header(&sendbuff, result);'))
                        lines.append(indent(2, 'int i = 0;'))
                        lines.append(indent(2, 'for (; i < result; i++) {'))
                        if fetched_type == "int*":
                            lines.append(indent(3, 'ei_x_encode_long(&sendbuff, %s[i]);' % fetched_name))
                        else:
                            print("unknown fetch type %s\n" % fetched_type)
                            continue;
                        lines.append(indent(2, '}'))
                        lines.append(indent(2, 'ei_x_encode_empty_list(&sendbuff);'))
                        docs.append("%s[%s]" % (fetched_name, fetched_type))
                    else:
                        if cb["cb_returns"] == "const char*":
                            lines.append(indent(2, 'ei_x_encode_string(&sendbuff, result);'))
                        elif cb["cb_returns"] == "char":
                            lines.append(indent(2, 'ei_x_encode_char(&sendbuff, result);'))
                        elif cb["cb_returns"] == "int":
                            lines.append(indent(2, 'ei_x_encode_long(&sendbuff, result);'))
                        elif cb["cb_returns"] == "float":
                            lines.append(indent(2, 'ei_x_encode_double(&sendbuff, result);'))
                        elif cb["cb_returns"] == "bool":
                            lines.append(indent(2, 'ei_x_encode_boolean(&sendbuff, result);'))
                        elif cb["cb_returns"] == "short":
                            lines.append(indent(2, 'ei_x_encode_long(&sendbuff, result);'))
                        else:
                            print("%s: unknown return type '%s'\n" % (name, cb["cb_returns"]))
                            continue
                        docs.append("result[%s]" % (cb["cb_returns"]))

                    lines.append(indent(2, 'return send_to_pid(skirmishAIId, &from, sendbuff);'))
                    lines.append(indent(1, '}'))
                    lines.append("")
                    cbgen_file.write("\n".join(lines))
                    doc_file.write("# %s\n" % " ".join(docs))
                cbgen_file.write(indent(1, 'return -1;\n'))
                cbgen_file.write(indent(0, '}\n'))


if __name__ == "__main__":
    misc_dirname = os.path.dirname(os.path.abspath(__file__))

    SourceGeneratorCallbacks(misc_dirname).generate()
    SourceGeneratorEvents(misc_dirname).generate()
    SourceGeneratorCommands(misc_dirname).generate()

